{"changed":true,"filter":false,"title":"h1.arraysstructs.cpp","tooltip":"/h1.arraysstructs.cpp","value":"//Lamog, Robert\n//Arrays & Structs\n//Hart\n//09/14/14\n\n#include<iostream>\n#include<string>\nusing namespace std;\n\n#define nArr 3\nstruct ABC{\n    unsigned n;\n    char c;\n    double a[nArr]; // is this ok, to have an array inside a struct? Absolutely!!\n};\n\nvoid show( const unsigned a[], unsigned elements );\nbool isPermutation( const unsigned a[], unsigned elements );\nvoid inverse( unsigned a[], const unsigned b[], unsigned elements );\nbool sorted( const unsigned a[], unsigned elements );\nvoid merge( unsigned combo[], const unsigned a[], unsigned aElements, const unsigned b[], unsigned bElements );\nunsigned long long sum( const unsigned a[], unsigned elements, unsigned f( unsigned n ) );\nunsigned cube( unsigned n );\n\nvoid show( const ABC & x );\nvoid show( const ABC arr[], unsigned elements );\ndouble max( const ABC & x );\ndouble max( const ABC arr[], unsigned elements );\nvoid set( ABC & x, unsigned n, char c, const double a[nArr] );\nvoid get( unsigned & n, char & c, double a[nArr], const ABC & x );\nvoid set( ABC x[], const unsigned n[], const char c[], const double a[][nArr], unsigned elements );\nvoid get( unsigned n[], char c[], double a[][nArr], const ABC x[], unsigned elements );\n\nbool die( const string & msg );\n\nint main(){\n/*\tunsigned a[] = {2, 4, 6, 8};\n\tshow( a, 4 );\n\n\tunsigned b[] = {3, 0, 2, 1};\n\tunsigned z[] = {0};\n\tbool boo = isPermutation( z, 1 );\n\tcout << boo << endl;\n\n\tinverse(a, b, 4);\n\tshow(a, 4);\n\t\n\tunsigned c[] = {1, 5, 5, 7};\n\tunsigned d[] = {1, 5, 3, 7};\n\tcout << sorted(c, 4) << endl;\n\tcout << sorted(d, 4) << endl;\n\t\n\tunsigned e[] = {3, 5, 7, 7, 9};\n\tunsigned f[] = {2, 5, 8, 1234};\n\tunsigned g[100];\n\tmerge(g, e, 1, f, 4);\n\tcout << endl;\n\n    unsigned h[] = {3, 5, 2, 1};\n    cout << sum(h, 4, cube);\n*/\n    ABC struct1 = {18, 'W', {1.1, 2.2, 3.3}};\n//    show(struct1);\n    \n    ABC struct2 = {123, 'A', {1.1, 2.2, 3.3}};\n    ABC struct3 = {234, 'B', {2.1, 2.2, 2.3}};\n    ABC struct4 = {345, 'C', {3.1, 3.2, 3.3}};\n    ABC struct5 = {456, 'D', {4.1, 4.2, 4.3}};\n    ABC arr1[4] = {struct2, struct3, struct4, struct5};\n//    show(arr1, 4);\n\n//    cout << max(struct1) << endl;\n//    cout << max(arr1, 4) << endl;\n    \n    ABC struct6;\n    double doubleArr[3] = {10.0, 20.0, 30.0};\n    set(struct6, 1234, '?', doubleArr);\n//    show(struct6);\n    double doubleArr1[3];\n    unsigned n;\n    char c;\n    get(n, c, doubleArr1, struct6);\n    \n    ABC arr2[4];\n    unsigned e[4] = {111, 222, 333, 444};\n    char f[4] = {'z', 'y', 'X', 'W'};\n    double g[4][nArr] = {\n        {1.1, 2.2, 3.3},\n        {2.1, 2.2, 2.3},\n        {3.1, 3.2, 3.3},\n        {4.1, 4.2, 4.3}\n    };\n    set(arr2, e, f, g, 4);\n    \n    ABC struct10 = {45, '!', {4.1, 4.2, 4.3}};\n    ABC struct7 = {34, '@', {3.1, 3.2, 3.3}};\n    ABC struct8 = {23, '#', {2.1, 2.2, 2.3}};\n    ABC struct9 = {12, '$', {1.1, 2.2, 3.3}};\n    ABC arr3[4] = {struct10, struct7, struct8, struct9};\n    unsigned h[4];\n    char i[4];\n    double j[4][nArr];\n    get(h, i, j, arr3, 4);\n    \n\t//system(\"pause\");\n\treturn 0;\n} //main()\n\nvoid show( const unsigned a[], unsigned elements ){\n\tcout << \"[\" << elements << \"]: \";\n\tfor (unsigned i = 0; i < elements; i++){\n\t\tcout << a[i];\n\t\tif (i != elements - 1) cout << \", \";\n\t}\n\tcout << endl;\n}\nbool isPermutation( const unsigned a[], unsigned elements ){\n\tbool isPerm = false;\n\tunsigned isDup = 0;\n\tfor (unsigned i = 0; i < elements; i++){\n\t\tfor (unsigned j = 0; j < elements; j++){\n\t\t\tif (a[i] == j) isPerm = true;\n\t\t\tif (a[i] == a[j]) isDup++;\n\t\t}\n\t\tif ((!isPerm) || (isDup > 1)) return false;\n\t\tisPerm = false;\n\t\tisDup = 0;\n\t}\n\treturn true;\n}\nvoid inverse( unsigned a[], const unsigned b[], unsigned elements ){\n\tif (!isPermutation(b, elements)) die(\"array b[] is not a permutation.\");\n\tfor (unsigned i = 0; i < elements; i++){\n\t\tfor (unsigned j = 0; j < elements; j++){\n\t\t\tif (b[i] == j) a[j] = i;\n\t\t}\n\t}\n}\nbool sorted( const unsigned a[], unsigned elements ){\n\tif (elements == 0) return true; //an array 0 elements is still an array\n\tfor (unsigned i = 0; i < elements; i++){\n\t\tif (i == elements - 1) return true;\n\t\tif (a[i] > a[i + 1]) return false;\n\t}\n\treturn false;\n}\nvoid merge( unsigned combo[], const unsigned a[], unsigned aElements, const unsigned b[], unsigned bElements ){\n\tunsigned aCount = 0;\n\tunsigned bCount = 0;\n\tbool endOfArr = false;\n\tunsigned comboSize = 0;\n\t\n\tif (!sorted(a, aElements)) die(\"array a[] is not sorted.\");\n\tif (!sorted(b, bElements)) die(\"array b[] is not sorted.\");\n\t\n    if (aElements == 0 || bElements == 0) endOfArr = true;\n\tcomboSize = aElements + bElements; // prototype suggests main implements combo[] length. this could be problematic should a plus b elements be larger than combo[] size.\n\t\n\tfor (unsigned i = 0; i < comboSize; i++){\n\t\tif ((aCount < aElements) && (bCount < bElements)){\n\t\t\tif (a[aCount] > b[bCount]){\n\t\t\t\tcombo[i] = b[bCount];\n\t\t\t\t//cout << \", b\" << combo[i];\n\t\t\t\tbCount++;\n\t\t\t\tif (bCount == bElements) endOfArr = true;\n\t\t\t} else {\n\t\t\t\tcombo[i] = a[aCount];\n\t\t\t\t//cout << \", a\" << combo[i];\n\t\t\t\taCount++;\n\t\t\t\tif (aCount == aElements) endOfArr = true;\n\t\t\t}\n\t\t}\n\t\tif (endOfArr){\n    \t\tif (aCount < aElements){\n    \t\t    combo[i] = a[aCount];\n    \t\t\t//cout << \", eor: a\" << combo[i];\n    \t\t    aCount++;\n    \t\t    continue;\n    \t\t}\n    \t\tif (bCount < bElements){\n    \t\t    combo[i] = b[bCount];\n    \t\t\t//cout << \", eor: b\" << combo[i];\n    \t\t    bCount++;\n    \t\t    continue;\n    \t\t}\n\t\t}\n\t}\n}\nunsigned long long sum( const unsigned a[], unsigned elements, unsigned f( unsigned n ) ){\n    unsigned long long total = 0;\n    \n    for (unsigned i = 0; i < elements; i++){\n        total += f(a[i]);\n    }\n    return total;\n}\nunsigned cube( unsigned n ){\n    return n * n * n;\n}\n\nvoid show( const ABC & x ){\n    cout << \"{\" << x.n << \", \\'\" << x.c << \"\\', {\";\n    for (unsigned i = 0; i < nArr; i++){\n        cout << x.a[i];\n        if (i != nArr - 1) cout << \", \";\n    }\n    cout << \"}}\" << endl;\n}\nvoid show( const ABC arr[], unsigned elements ){\n    for (unsigned i = 0; i < elements; i++) show(arr[i]);\n}\ndouble max( const ABC & x ){\n    double maxInABC;\n    maxInABC = x.a[0]; // I failed to notice lowest value could be negative. /*solved*/\n    \n    for (unsigned i = 0; i < nArr; i++){\n        if (x.a[i] > maxInABC) maxInABC = x.a[i];\n    }\n    return maxInABC;\n}\ndouble max( const ABC arr[], unsigned elements ){\n    double maxInABCs;\n    maxInABCs = max(arr[0]); // I failed to notice lowest value could be negative. /*solved*/\n    \n    for (unsigned i = 0; i < elements; i++){\n        if (max(arr[i]) > maxInABCs) maxInABCs = max(arr[i]);\n    }\n    return maxInABCs;\n}\nvoid set( ABC & x, unsigned n, char c, const double a[nArr] ){\n    x.n = n;\n    x.c = c;\n    for (unsigned i = 0; i < nArr; i++) x.a[i] = a[i];\n}\nvoid get( unsigned & n, char & c, double a[nArr], const ABC & x ){\n    n = x.n;\n    c = x.c;\n    for (unsigned i = 0; i < nArr; i++) a[i] = x.a[i];\n    \n/*    //test code\n    cout << \"{\" << n << \", \\'\" << c << \"\\', {\";\n    for (unsigned j = 0; j < nArr; j++){\n        cout << x.a[j];\n        if (j != nArr - 1) cout << \", \";\n    }\n    cout << \"}}\" << endl;\n*/\n}\nvoid set( ABC x[], const unsigned n[], const char c[], const double a[][nArr], unsigned elements ){\n    for (unsigned i = 0; i < elements; i++){\n        set(x[i], n[i], c[i], a[i]);\n\n/*        //test code\n        cout << \"{\" << x[i].n << \", \\'\" << x[i].c << \"\\', {\";\n        for (unsigned j = 0; j < nArr; j++){\n            cout << x[i].a[j];\n            if (j != nArr - 1) cout << \", \";\n        }\n        cout << \"}}\" << endl;\n*/\n    }\n}\nvoid get( unsigned n[], char c[], double a[][nArr], const ABC x[], unsigned elements ){\n    for (unsigned i = 0; i < elements; i++){\n        n[i] = x[i].n;\n        c[i] = x[i].c;\n        for (unsigned j = 0; j < nArr; j++){\n            a[i][j] = x[i].a[j];\n        }\n\n/*        //test code\n        cout << \"{\" << x[i].n << \", \\'\" << x[i].c << \"\\', {\";\n        for (unsigned j = 0; j < nArr; j++){\n            cout << x[i].a[j];\n            if (j != nArr - 1) cout << \", \";\n        }\n        cout << \"}}\" << endl;\n/**/\n    }\n}\n\nbool die( const string & msg ){\n\t//cerr <<endl <<\"Fatal error: \" <<msg << endl;\n\t//exit( EXIT_FAILURE );\n\n\tcout << endl << \"Fatal error: \" << msg << endl;\n\treturn true;\n}\n","undoManager":{"mark":14,"position":20,"stack":[[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":12}},"text":"//Lamog, Rob"},{"action":"insertText","range":{"start":{"row":0,"column":12},"end":{"row":1,"column":0}},"text":"\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":288,"column":0}},"lines":["//h1.Arrays & Structs","//Hart","//09/09/13","","#include<iostream>","#include<string>","using namespace std;","","#define nArr 3","struct ABC{","    unsigned n;","    char c;","    double a[nArr]; // is this ok, to have an array inside a struct? Absolutely!!","};","","void show( const ABC & x );","void show( const ABC arr[], unsigned elements );","double max( const ABC & x );","double max( const ABC arr[], unsigned elements );","void set( ABC & x, unsigned n, char c, const double a[nArr] );","void get( unsigned & n, char & c, double a[nArr], const ABC & x );","void set( ABC x[], const unsigned n[], const char c[], const double a[][nArr], unsigned elements );","void get( unsigned n[], char c[], double a[][nArr], const ABC x[], unsigned elements );","","void show( const unsigned a[], unsigned elements );","bool isPermutation( const unsigned a[], unsigned elements );","void inverse( unsigned a[], const unsigned b[], unsigned elements );","bool sorted( const unsigned a[], unsigned elements );","void merge( unsigned combo[], const unsigned a[], unsigned aElements, const unsigned b[], unsigned bElements );","unsigned long long sum( const unsigned a[], unsigned elements, unsigned f( unsigned n ) );","unsigned cube( unsigned n );","","bool die( const string & msg );","","int main(){","/*\tunsigned a[] = {2, 4, 6, 8};","\tshow( a, 4 );","","\tunsigned b[] = {3, 0, 2, 1};","\tunsigned z[] = {0};","\tbool boo = isPermutation( z, 1 );","\tcout << boo << endl;","","\tinverse(a, b, 4);","\tshow(a, 4);","\t","\tunsigned c[] = {1, 5, 5, 7};","\tunsigned d[] = {1, 5, 3, 7};","\tcout << sorted(c, 4) << endl;","\tcout << sorted(d, 4) << endl;","\t","\tunsigned e[] = {3, 5, 7, 7, 9};","\tunsigned f[] = {2, 5, 8, 1234};","\tunsigned g[100];","\tmerge(g, e, 1, f, 4);","\tcout << endl;","","    unsigned h[] = {3, 5, 2, 1};","    cout << sum(h, 4, cube);","*/","    ABC struct1 = {18, 'W', {1.1, 2.2, 3.3}};","//    show(struct1);","    ","    ABC struct2 = {123, 'A', {1.1, 2.2, 3.3}};","    ABC struct3 = {234, 'B', {2.1, 2.2, 2.3}};","    ABC struct4 = {345, 'C', {3.1, 3.2, 3.3}};","    ABC struct5 = {456, 'D', {4.1, 4.2, 4.3}};","    ABC arr1[4] = {struct2, struct3, struct4, struct5};","//    show(arr1, 4);","","//    cout << max(struct1) << endl;","//    cout << max(arr1, 4) << endl;","    ","    ABC struct6;","    double doubleArr[3] = {10.0, 20.0, 30.0};","    set(struct6, 1234, '?', doubleArr);","//    show(struct6);","    double doubleArr1[3];","    unsigned n;","    char c;","    get(n, c, doubleArr1, struct6);","    ","    ABC arr2[4];","    unsigned e[4] = {111, 222, 333, 444};","    char f[4] = {'z', 'y', 'X', 'W'};","    double g[4][nArr] = {","        {1.1, 2.2, 3.3},","        {2.1, 2.2, 2.3},","        {3.1, 3.2, 3.3},","        {4.1, 4.2, 4.3}","    };","    set(arr2, e, f, g, 4);","    ","    ABC struct10 = {45, '!', {4.1, 4.2, 4.3}};","    ABC struct7 = {34, '@', {3.1, 3.2, 3.3}};","    ABC struct8 = {23, '#', {2.1, 2.2, 2.3}};","    ABC struct9 = {12, '$', {1.1, 2.2, 3.3}};","    ABC arr3[4] = {struct10, struct7, struct8, struct9};","    unsigned h[4];","    char i[4];","    double j[4][nArr];","    get(h, i, j, arr3, 4);","    ","\t//system(\"pause\");","\treturn 0;","} //main()","","void show( const unsigned a[], unsigned elements ){","\tcout << \"[\" << elements << \"]: \";","\tfor (unsigned i = 0; i < elements; i++){","\t\tcout << a[i];","\t\tif (i != elements - 1) cout << \", \";","\t}","\tcout << endl;","}","bool isPermutation( const unsigned a[], unsigned elements ){","\tbool isPerm = false;","\tunsigned isDup = 0;","\tfor (unsigned i = 0; i < elements; i++){","\t\tfor (unsigned j = 0; j < elements; j++){","\t\t\tif (a[i] == j) isPerm = true;","\t\t\tif (a[i] == a[j]) isDup++;","\t\t}","\t\tif ((!isPerm) || (isDup > 1)) return false;","\t\tisPerm = false;","\t\tisDup = 0;","\t}","\treturn true;","}","void inverse( unsigned a[], const unsigned b[], unsigned elements ){","\tif (!isPermutation(b, elements)) die(\"array b[] is not a permutation.\");","\tfor (unsigned i = 0; i < elements; i++){","\t\tfor (unsigned j = 0; j < elements; j++){","\t\t\tif (b[i] == j) a[j] = i;","\t\t}","\t}","}","bool sorted( const unsigned a[], unsigned elements ){","\tif (elements == 0) return true; //an array 0 elements is still an array","\tfor (unsigned i = 0; i < elements; i++){","\t\tif (i == elements - 1) return true;","\t\tif (a[i] > a[i + 1]) return false;","\t}","\treturn false;","}","void merge( unsigned combo[], const unsigned a[], unsigned aElements, const unsigned b[], unsigned bElements ){","\tunsigned aCount = 0;","\tunsigned bCount = 0;","\tbool endOfArr = false;","\tunsigned comboSize = 0;","\t","\tif (!sorted(a, aElements)) die(\"array a[] is not sorted.\");","\tif (!sorted(b, bElements)) die(\"array b[] is not sorted.\");","\t","    if (aElements == 0 || bElements == 0) endOfArr = true;","\tcomboSize = aElements + bElements; // prototype suggests main implements combo[] length. this could be problematic should a plus b elements be larger than combo[] size.","\t","\tfor (unsigned i = 0; i < comboSize; i++){","\t\tif ((aCount < aElements) && (bCount < bElements)){","\t\t\tif (a[aCount] > b[bCount]){","\t\t\t\tcombo[i] = b[bCount];","\t\t\t\t//cout << \", b\" << combo[i];","\t\t\t\tbCount++;","\t\t\t\tif (bCount == bElements) endOfArr = true;","\t\t\t} else {","\t\t\t\tcombo[i] = a[aCount];","\t\t\t\t//cout << \", a\" << combo[i];","\t\t\t\taCount++;","\t\t\t\tif (aCount == aElements) endOfArr = true;","\t\t\t}","\t\t}","\t\tif (endOfArr){","    \t\tif (aCount < aElements){","    \t\t    combo[i] = a[aCount];","    \t\t\t//cout << \", eor: a\" << combo[i];","    \t\t    aCount++;","    \t\t    continue;","    \t\t}","    \t\tif (bCount < bElements){","    \t\t    combo[i] = b[bCount];","    \t\t\t//cout << \", eor: b\" << combo[i];","    \t\t    bCount++;","    \t\t    continue;","    \t\t}","\t\t}","\t}","}","unsigned long long sum( const unsigned a[], unsigned elements, unsigned f( unsigned n ) ){","    unsigned long long total = 0;","    ","    for (unsigned i = 0; i < elements; i++){","        total += f(a[i]);","    }","    return total;","}","unsigned cube( unsigned n ){","    return n * n * n;","}","","void show( const ABC & x ){","    cout << \"{\" << x.n << \", \\'\" << x.c << \"\\', {\";","    for (unsigned i = 0; i < nArr; i++){","        cout << x.a[i];","        if (i != nArr - 1) cout << \", \";","    }","    cout << \"}}\" << endl;","}","void show( const ABC arr[], unsigned elements ){","    for (unsigned i = 0; i < elements; i++) show(arr[i]);","}","double max( const ABC & x ){","    double maxInABC;","    maxInABC = x.a[0]; //failed to notice lowest value could be negative. /*solved*/","    ","    for (unsigned i = 0; i < nArr; i++){","        if (x.a[i] > maxInABC) maxInABC = x.a[i];","    }","    return maxInABC;","}","double max( const ABC arr[], unsigned elements ){","    double maxInABCs;","    maxInABCs = max(arr[0]); //failed to notice lowest value could be negative. /*solved*/","    ","    for (unsigned i = 0; i < elements; i++){","        if (max(arr[i]) > maxInABCs) maxInABCs = max(arr[i]);","    }","    return maxInABCs;","}","void set( ABC & x, unsigned n, char c, const double a[nArr] ){","    x.n = n;","    x.c = c;","    for (unsigned i = 0; i < nArr; i++) x.a[i] = a[i];","}","void get( unsigned & n, char & c, double a[nArr], const ABC & x ){","    n = x.n;","    c = x.c;","    for (unsigned i = 0; i < nArr; i++) a[i] = x.a[i];","    ","/*    //test code","    cout << \"{\" << n << \", \\'\" << c << \"\\', {\";","    for (unsigned j = 0; j < nArr; j++){","        cout << x.a[j];","        if (j != nArr - 1) cout << \", \";","    }","    cout << \"}}\" << endl;","*/","}","void set ( ABC x[], const unsigned n[], const char c[], const double a[][nArr], unsigned elements ){","    for (unsigned i = 0; i < elements; i++){","        set(x[i], n[i], c[i], a[i]);","","/*        //test code","        cout << \"{\" << x[i].n << \", \\'\" << x[i].c << \"\\', {\";","        for (unsigned j = 0; j < nArr; j++){","            cout << x[i].a[j];","            if (j != nArr - 1) cout << \", \";","        }","        cout << \"}}\" << endl;","*/","    }","}","void get( unsigned n[], char c[], double a[][nArr], const ABC x[], unsigned elements ){","    for (unsigned i = 0; i < elements; i++){","        n[i] = x[i].n;","        c[i] = x[i].c;","        for (unsigned j = 0; j < nArr; j++){","            a[i][j] = x[i].a[j];","        }","","        //test code","        cout << \"{\" << x[i].n << \", \\'\" << x[i].c << \"\\', {\";","        for (unsigned j = 0; j < nArr; j++){","            cout << x[i].a[j];","            if (j != nArr - 1) cout << \", \";","        }","        cout << \"}}\" << endl;","/**/","    }","}","","bool die( const string & msg ){","\t//cerr <<endl <<\"Fatal error: \" <<msg << endl;","\t//exit( EXIT_FAILURE );","","\tcout << endl << \"Fatal error: \" << msg << endl;","\treturn true;","}"]}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":31,"column":0},"end":{"row":31,"column":28}},"text":"unsigned cube( unsigned n );"},{"action":"removeLines","range":{"start":{"row":24,"column":0},"end":{"row":31,"column":0}},"nl":"\n","lines":["","void show( const unsigned a[], unsigned elements );","bool isPermutation( const unsigned a[], unsigned elements );","void inverse( unsigned a[], const unsigned b[], unsigned elements );","bool sorted( const unsigned a[], unsigned elements );","void merge( unsigned combo[], const unsigned a[], unsigned aElements, const unsigned b[], unsigned bElements );","unsigned long long sum( const unsigned a[], unsigned elements, unsigned f( unsigned n ) );"]},{"action":"removeText","range":{"start":{"row":23,"column":87},"end":{"row":24,"column":0}},"text":"\n"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":14,"column":2},"end":{"row":15,"column":0}},"text":"\n"},{"action":"insertLines","range":{"start":{"row":15,"column":0},"end":{"row":22,"column":0}},"lines":["","void show( const unsigned a[], unsigned elements );","bool isPermutation( const unsigned a[], unsigned elements );","void inverse( unsigned a[], const unsigned b[], unsigned elements );","bool sorted( const unsigned a[], unsigned elements );","void merge( unsigned combo[], const unsigned a[], unsigned aElements, const unsigned b[], unsigned bElements );","unsigned long long sum( const unsigned a[], unsigned elements, unsigned f( unsigned n ) );"]},{"action":"insertText","range":{"start":{"row":22,"column":0},"end":{"row":22,"column":28}},"text":"unsigned cube( unsigned n );"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":12},"end":{"row":0,"column":13}},"text":"e"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":13},"end":{"row":0,"column":14}},"text":"r"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":14},"end":{"row":0,"column":15}},"text":"t"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":3,"column":5},"end":{"row":3,"column":7}},"text":"09"},{"action":"insertText","range":{"start":{"row":3,"column":5},"end":{"row":3,"column":6}},"text":"1"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":3,"column":6},"end":{"row":3,"column":7}},"text":"4"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":3,"column":9},"end":{"row":3,"column":10}},"text":"3"},{"action":"insertText","range":{"start":{"row":3,"column":9},"end":{"row":3,"column":10}},"text":"4"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":1,"column":4},"end":{"row":1,"column":5}},"text":"."}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":1,"column":3},"end":{"row":1,"column":4}},"text":"1"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":1,"column":2},"end":{"row":1,"column":3}},"text":"h"}]}],[{"group":"doc","deltas":[{"action":"removeText","range":{"start":{"row":248,"column":8},"end":{"row":248,"column":9}},"text":" "}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":270,"column":0},"end":{"row":270,"column":1}},"text":"/"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":270,"column":1},"end":{"row":270,"column":2}},"text":"*"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":222,"column":31},"end":{"row":222,"column":32}},"text":" "}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":222,"column":32},"end":{"row":222,"column":33}},"text":"I"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":222,"column":33},"end":{"row":222,"column":34}},"text":" "}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":213,"column":25},"end":{"row":213,"column":26}},"text":" "}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":213,"column":26},"end":{"row":213,"column":27}},"text":"I"}]}],[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":213,"column":27},"end":{"row":213,"column":28}},"text":" "}]}]]},"ace":{"folds":[],"scrolltop":62,"scrollleft":0,"selection":{"start":{"row":213,"column":28},"end":{"row":213,"column":28},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":2,"state":"start","mode":"ace/mode/c_cpp"}},"timestamp":1410229570774}